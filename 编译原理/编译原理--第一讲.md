# 							编译原理--第一讲

# 														引论			

## 1.1什么是编译程序

### 					编译原理主要内容：介绍程序设计语言==编译程序构造==的==基本原理==和==基本实现技术==

### 					翻译程序（Translator）：把某一种语言程序（称为==源语言程序==）等价地转换成另一种语言程序（称为==目标语言程序==）的程序

### 					编译程序（Compiler）：把某一种==高级语言程序==等价地转换成另一种==低级语言程序==（如汇编语言或机器语言程序）的程序

#### 									编译程序分类：1、诊断编译程序（Diagnostic Compiler）2、优化编译程序（Optimizing Compiler）3、交叉编译程序（Cross Compiler）4、可变目标编译程序（Retargetable Compiler）

### 					解释程序（Interpreter）：把源语言编写的==源程序==作为输入，但不产生目标程序，而是==边解释边执行==源程序

## 1.2为什么要学习编译原理

### 					学习目的：1、理解计算系统	2、设计计算系统	3、训练计算思维（Computational Thinking）

### 					计算思维是什么[J.Wang，2006]：==计算思维==是运用计算机科学的基础概念去求解问题、设计系统和理解人类行为，它包括了一系列广泛的计算机科学的思维方法。

#### 							经典的计算机科学的思维方法：抽象、自动化、问题分解、递归、权衡、保护、冗余、容错、纠错和恢复，利用启发式推理来寻求解答、在不确定情况下的规划、学习和调度。。。					

#### 							关于抽象（Abstraction）的很多说法：

##### 														1、忽略一个主题当中与当前问题（或目标）无关的那些方面，以便更充分的注意与当前问题（或目标）有关的方面

##### 														2、从众多的事物中抽取出共同的、本质性的特征、舍弃其非本质性的特征

##### 														3、是一种从个体把握一般、从现象把握本质的认知过程和思维方法

#### 							自动化（Automation）:

##### 														1、将抽象思维的结果在计算机上实现，是一个将计算思维成果物化的过程，也是将理论成果应用于技术的实践			

##### 														2、自动化的思维方法不仅体现在编译程序本身的机制上，更体现在了编译程序的生成工具的

##### 研究和设计上

##### 														编译原理中的自动机：有限自动机、预测分析程序、算符优先分析程序、LR分析程序。。。

#### 							分解（Decomposition）:

##### 														将大规模的复杂问题分解成若干个较小规模的、更简单的问题加以解决

#### 							递归（Recursion）:

##### 														问题的解决依赖于类似问题的解决，只不过后者的复杂程度或者规模较原来的问题更小，一旦将问题的复杂程度和规模简化到足够小时，问题的解法其实很简单

#### 							权衡（折中，Tradeoff）:

##### 													理论研究重在探寻问题求解的方法，对于理论成果的研究运用又需要在能力和运用中作出权衡

## 1.3编译过程

#### 		词法分析：

##### 					1、任务：输入源程序，对构成源程序的字符串进行扫描和分解，识别出单词符号

##### 					2、依循的原则：构词规则

##### 					3、描述工具：有限自动机

##### 					for 			i			 := 			1 			to 			100 		do

##### 					基本字	标识符	赋值号	整常数	 基本字	  整常数	基本字

#### 		语法分析：

##### 					1、任务：在词法分析的基础上，根据语法规则把单词符号串分解成各类语法单位（语法范畴）

##### 					2、依循的原则：语法规则

##### 					3、描述工具：上下文无关文法

##### 					Pascal 风格：Z  :=  X + 0.618 * Y     解释：（0.618 * Y ）算术表达式 + （X + 0.618 * Y） 算术表达式 +（ Z） +（ 赋值号）==构成==赋值语句

#### 		中间代码产生：

##### 					1、任务：对各类语法单位按语言的==语义==进行初步翻译

##### 					2、依循规则：语义规则

##### 					3、描述工具：属性文法

##### 					4、中间代码：三元式、四元式、树。。。。

##### 					Z  :=  X + 0.618 * Y    翻译成四元式为：

| 序号  | OPR  | OPN1  | OPN2 | RESULT |      注释       |
| :---: | :--: | :---: | :--: | :----: | :-------------: |
| （1） |  *   | 0.618 |  Y   |   T1   | T1 := 0.618 * Y |
| （2） |  +   |   X   |  T1  |   T2   |  T2 := X + T1   |
| （3） |  :=  |  T2   |      |   Z    |     Z := T2     |

#### 		优化：

##### 					1、任务：对前阶段产生的中间代码进行加工变换，以期在最后阶段产生更高效的目标代码

##### 					2、依循的原则：程序的等价变换原则

##### 					

```c
FOR K := 1 TO 100 DO
BEGIN
  	X := I + 1;
		M := I + 10*K;
		N := J + 10*K;
END
```

| 序号 | OPR  | OPN1 | OPN2 | RESULT |        注释         |
| :--: | :--: | :--: | :--: | :----: | :-----------------: |
| (1)  |  :=  |  1   |      |   K    |        K:=1         |
| (2)  |  J<  | 100  |  K   |  (10)  | if(100<K) goto (10) |
| (3)  |  +   |  I   |  1   |   X    |       X:=I+1        |
| (4)  |  *   |  10  |  K   |   T1   |       T1=10*K       |
| (5)  |  +   |  I   |  T1  |   M    |       M:=I+T1       |
| (6)  |  *   |  10  |  K   |   T2   |       T2=10*K       |
| (7)  |  +   |  J   |  T2  |   N    |       N:=J+T2       |
| (8)  |  +   |  K   |  1   |   K    |       K:=K+1        |
| (9)  |  J   |      |      |  (2)   |      goto (2)       |
| (10) |      |      |      |        |                     |

##### 优化前：400个加法	200个乘法

##### 经过优化后：301个加法

| 序号 | OPR  | OPN1 | OPN2 | RESULT |        注释         |
| :--: | :--: | :--: | :--: | :----: | :-----------------: |
| (1)  |  +   |  I   |  1   |   X    |       X:=I+1        |
| (2)  |  :=  |  I   |      |   M    |        M:=I         |
| (3)  |  :=  |  J   |      |   N    |        N:=J         |
| (4)  |  :=  |  1   |      |   K    |        K:=1         |
| (5)  |  J<  | 100  |  K   |  (10)  | if(K<100) goto (10) |
| (6)  |  +   |  M   |  10  |   M    |      M := M+10      |
| (7)  |  +   |  N   |  10  |   N    |      N := N+10      |
| (8)  |  +   |      |  1   |   K    |      K := K+1       |
| (9)  |  J   |      |      |  (5)   |      goto (5)       |
| (10) |      |      |      |        |                     |

#### 		目标代码生成：

##### 					1、任务：把中间代码转换成特定机器上的目标代码

##### 					2、依赖于硬件系统和机器指令的含义

##### 					3、目标代码三种形式：

###### 									1、汇编指令代码：需要进行汇编（汇编器）

###### 									2、可重新定位指令代码：需要连接

###### 									3、绝对指令代码：可直接运行

##### 					举例：b=a+2

```c
																操作码		寄存器操作数	操作数标志	 地址或立即数（星号标志相对地址）
MOV a, R1												0001		01					00				00000000*
ADD #2, R1	(汇编)-->(机器指令)	  0011	  01					10				00000010
MOV R1, b    										0100    01					00				00000100*
```

##### 链接前----相对之地，链接后才可执行

##### 链接后----绝对地址，可直接执行

```c
假设该模块儿在内存中的起点是	L = 00001111
那么 a 和 b 的相对地址加上该起点，相对地址变成绝对地址
0001 01 00 00001111
0011 01 10 00000010
0100 01 00 00010011
```



## 1.4编译程序的结构

#### 		编译程序总框：

##### 					源程序		              ---->	词法分析器

##### 					单词符号	              ---->	语法分析器

##### 					语法单位				  ---->	语义分析与中间代码生成器

##### 					中间代码(四元式)	---->	优化段

##### 					中间代码(四元式)	---->	目标代码生成器

##### 					目标代码

##### 					符号表管理：各种对象的信息的存储、组织和修改，为个阶段的分析和转换提供依据，每个阶段都会跟它打交道

##### 					出错处理：处理各个阶段出现的错误，把有关错误信息报告给用户

###### 									语法错误：1、源程序中不符合语法（或词法）规则的错误	2、非法字符、括号不匹配、缺少；。。。

###### 									语义错误：1、源程序中不符合语义规则的错误	2、说明错误、作用域错误、类型不一致。。。

#### 		遍（pass）：对源程序或源程序的中间表示从头到尾扫描一次，阶段与遍概念不同，一遍可以由若干段组成 或者 一个阶段分成若干遍来完成

#### 		编译前端与后端：

##### 					源语言	--前端-->	中间语言	--后端-->	目标语言

##### 					编译前端：与源语言有关，如词法分析、语法分析、语义分析与中间代码生成，与机器无关的优化

##### 					编译后段：与目标机有关，与目标机的优化有关，目标代码产生

##### 					带来的好处：1、程序逻辑结构清晰	2、优化更充分，有利于移植

## 1.5编译程序的生成

#### 		以机器语言和汇编语言为工具：

##### 					优点：可以针对具体的机器，充分发挥计算机的系统功能，生成的程序效率高

##### 					缺点：程序难读、难写、易出错、难维护、生产效率低

#### 		高级语言书写：利用已有的某种语言的编译序实现另一语言的编译程序

##### 					优点：程序易读、易理解、容易维护、生产效率高

#### 		程序移植方法：把一种机器上的编译程序移植到另一种机器上

#### 		自编译方式：编译程序自动产生

##### 					编译程序--编译程序，编译程序产生器，编译程序书写系统

##### 					LEX：词法分析程序产生器

##### 					YACC：语法分析程序产生器

## 1.6小结

#### 		课程概述：

##### 					内容、意义

#### 		什么是编译程序：

##### 					翻译、编译、解释

#### 		编译基本过程：

#### 		编译程序的结构：

##### 					阶段、遍、前端/后端

#### 		编译程序生成的几种方法：